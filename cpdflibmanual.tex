\documentclass[a4paper]{memoir}
\usepackage{palatino}
\usepackage{microtype}
\usepackage{graphics}
\usepackage[plainpages=false,pdfpagelabels,pdfborder=0 0 0]{hyperref}
\newcommand{\smallgap}{\vspace{4mm}}
\newcommand{\cpdf}{\texttt{cpdf}}
\addtolength{\textwidth}{20mm}
\makeindex
\begin{document}
\frontmatter
\thispagestyle{empty}

\begin{flushright}

{\sffamily \bfseries \Huge Coherent PDF Library}

\vspace{12mm}

{\Huge Developer's Manual}\\\vspace{2mm}
Version 1.7 (August 2013)

\vspace{25mm}

\vfill

\includegraphics{logo.pdf}

\vspace{2mm}
{\sffamily \bfseries \LARGE Coherent Graphics Ltd}

\end{flushright}

\clearpage

\thispagestyle{empty}
\noindent For bug reports, feature requests and comments, email\\ \texttt{contact@coherentgraphics.co.uk}

\vspace*{\fill}
\noindent\copyright 2013 Coherent Graphics Limited. All rights reserved.

\smallgap 
\noindent Adobe, Acrobat, Adobe PDF, Adobe Reader and PostScript are
registered trademarks of Adobe Systems Incorporated. Windows, Powerpoint and
Excel are registered trademarks of Microsoft Corporation.

% Letter
\cleardoublepage
\tableofcontents

\cleardoublepage
\mainmatter
\chapterstyle{hangnum}
\pagestyle{ruled}
\chapter{Installation}
The Coherent PDF Library is provided either in binary form (three archive files \texttt{libcpdf.a}, \texttt{libbigarray.a}, \texttt{libunix.a} and the library header \texttt{cpdflibwrapper.h}), or as source. Instructions for building from source are included in the distribution.

\section{Installation}
Place \texttt{libcpdf.a}, \texttt{libbigarray.a}, and \texttt{libunix.a} somewhere suitable. Instruct your C linker to link with them. Place \texttt{cpdflibwrapper.h} somewhere suitable and instuct your C compiler to search for headers there.

\vspace{3mm}
\noindent The library is now ready for use.

\chapter{Basic Usage}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!FromFile! & Load PDF from file\\
\verb!FromFileLazy! & Load PDF from file lazily\\
\verb!FromFileDecrypt! & Load a PDF from file and decrypt it\\[5mm]
\verb!BlankDocument! & Make a blank document given page dimensions\\
\verb!BlankDocumentPaper! & Make a blank document given named paper size\\[5mm]
\verb!IsEncrypted! & Check whether a PDF is encrypted\\
\verb!DecryptPdf! & Decrypt a PDF using the user password\\
\verb!DecryptPdfOwner! & Decrypt a PDF using the owner password\\[5mm]
\verb!ToFile! & Write a PDF to file\\
\verb!ToFileEncrypted! & Write a PDF to file, encrypting it\\[5mm]
\verb!Pages! & Count the number of pages in a PDF\\[5mm]
\verb!All! & Build the page range representing all pages in a PDF\\
\verb!Range! & Build a page subrange\\
\verb!Even! & Build the page range of all odd pages\\
\verb!Odd! & Build the page range of all even pages\\
\verb!Difference! & Build the difference of two ranges\\
\verb!RemoveDuplicates! & Remove duplicates from a range\\
\verb!Sort! & Sort a range
\end{tabular}
\end{framed}
The Coherent PDF Toolkit for .NET provides a wide range of facilities for
modifying PDF files created by other means. There is a single library
\texttt{Coherent.PDFTools.dll}. The top-level module contaning the main functions is \texttt{Cpdflib}. We use these terms interchangeably.

The rest of this manual describes the functions available in that library.

\section{Reading PDF from Files and Memory}
The type of pdf files in memory is \texttt{Pdf.pdfdoc}. To load a PDF from file, assuming it is unencrypted, call \texttt{FromFile}, giving the file name as a \texttt{string}:
\begin{framed}
\noindent\textit{Opening a File}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc pdf = Cpdflib.FromFile("in.pdf")!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim pdf As Pdf.pdfdoc = Cpdflib.FromFile("in.pdf")!
\end{minipage}
\end{tabular}
\end{framed}

(If the file is encrypted, but only with a blank user password, it will be decrypted. This is identical to Acrobat's behaviour.)

If the file is encrypted, you must decrypt it to load it fully. This requires
either the user or owner password.
\begin{framed}
\noindent\textit{Opening an Encrypted File}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc pdf = Cpdflib.FromFileDecrypt("in.pdf", "pw")!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim pdf As Pdf.pdfdoc = Cpdflib.FromFileDecrypt("in.pdf", "pw")!
\end{minipage}
\end{tabular}
\end{framed}

If the operations to be performed on the PDF are limited to reading some metadata, or accessing just a portion of the file, it can be more memory- and time-efficient not to load or parse all the PDF upon opening. The only caveat is that the file must be available until the PDF object is destroyed - writing to or removing that file will result in an error.

\begin{framed}
\noindent\textit{Opening an File Lazily}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc pdf = Cpdflib.FromFileLazy("in.pdf")!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim pdf As Pdf.pdfdoc = Cpdflib.FromFileLazy("in.pdf")!
\end{minipage}
\end{tabular}
\end{framed}

No decryption is performed here (even if the password is blank), since it would
involve loading the whole file, so you must explicitly check if the file is
encrypted using \verb!IsEncrypted! and decrypt it before performing any
operation which requires the file to be in a decrypted state.

\section{Creating a Blank Document}
PDF Documents can also be created from scratch. To build a 20-page blank document with pages of width 500pts and height 600pts:
\begin{framed}
\noindent\textit{Making a Blank Document Given Paper Dimensions}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc pdf = Cpdflib.BlankDocument(500.0, 600.0, 20)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim pdf As Pdf.pdfdoc = Cpdflib.BlankDocument(500.0, 600.0, 20)!
\end{minipage}\\[5mm]
\end{tabular}\\

\end{framed}

To build a 20-page blank document using the US Letter paper size.
\begin{framed}
\noindent\textit{Making a Blank Document Given a Named Paper Size}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc pdf = !\\
\small\verb!  Cpdflib.BlankDocumentPaper(Cpdflib.usletterportrait, 20)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim pdf As Pdf.pdfdoc = !\\
\small\verb!  Cpdflib.BlankDocumentPaper(Cpdflib.usletterportrait, 20)!
\end{minipage}\\[5mm]
\end{tabular}\\

\end{framed}

Here are the standard paper sizes:

  \smallgap
  \begin{tabular}{lll}
  \texttt{a0portrait} & \texttt{a1portrait} & \texttt{a2portrait} \\
  \texttt{a3portrait} & \texttt{a4portrait} & \texttt{a5portrait} \\
  \texttt{a0landscape} & \texttt{a1landscape} & \texttt{a2landscape} \\
  \texttt{a3landscape} & \texttt{a4landscape} & \texttt{a5landscape} \\
  \texttt{usletterportrait} & \texttt{usletterlandscape} & \\
  \texttt{uslegalportrait} & \texttt{uslegallandscape} &
  \end{tabular}


\section{Writing PDF to Files and Memory}
Writing a PDF to file is achieved with the \verb!ToFile! function. The arguments are the PDF, the filename and two booleans - the first is true if the file is to be linearized, the second if a new /ID is to be made for the file.
\begin{framed}
\noindent\textit{Writing a File}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ToFile(pdf, "out.pdf", false, true)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ToFile(pdf, "out.pdf", false, true)!
\end{minipage}\\[5mm]
\end{tabular}\\

\noindent\textit{(In these examples, the file is not linearized, but a new /ID is made - hence \texttt{false, true}.)}
\end{framed}

To write a file encrypted, use \verb!ToFileEncrypted!.

\begin{framed}
\noindent\textit{Encryption Methods}

\vspace{2mm}
\noindent\small\verb!Pdfwrite.encryption_method.PDF40bit!\\
\small\verb!Pdfwrite.encryption_method.PDF128bit!\\
\small\verb!Pdfwrite.encryption_method.NewAES128bit(false)!\\
\small\verb!Pdfwrite.encryption_method.NewAES128bit(true)!
\end{framed}
Here are the possible permissions:

\begin{framed}
\begin{tabular}{ll}
\multicolumn{2}{l}{\textit{Using any form of encryption:}}\\[2mm]
\verb!Pdfcrypt.NoEdit! & Cannot change the document\\
\verb!Pdfcrypt.NoPrint! & Cannot print the document\\
\verb!Pdfcrypt.NoCopy! & Cannot select or copy text or graphics\\
\verb!Pdfcrypt.NoAnnot! & Cannot add or change form fields or annotations\\[3mm]
\multicolumn{2}{l}{\textit{Using 128 bit or AES encryption only:}}\\[2mm]
\verb!Pdfcrypt.NoForms! & Cannot edit form fields \\
\verb!Pdfcrypt.NoExtract! & Cannot extract text or graphics\\
\verb!Pdfcrypt.NoAssemble! & Cannot merge files etc.\\
\verb!Pdfcrypt.NoHqPrint! & Cannot print high-quality
\end{tabular}
\end{framed}

So to write a file encypted, we pass the PDF object, an encryption method, an
array of permissions, an owner password, user password, linearize flag and the
filename.

\begin{framed}
\noindent\textit{Writing a File Encrypted}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\begin{tabbing}
\small\verb!Pdfcrypt.permission[] permissions =                !\=\\
\small\verb! {Pdfcrypt.permission.NoEdit,!\\
\small\verb!  Pdfcrypt.permission.NoAssemble};!\\
\small\verb!Cpdflib.ToFileEncrypted!\\
\small\verb!  (pdf,                                             !\>\textit{Document}\\
\small\verb!   Pdfwrite.encryption_method.NewAES128bit(false),  !\>\textit{Encryption}\\
\small\verb!   permissions,                                  !\>\textit{Permissions}\\
\small\verb!   "fred",                                       !\>\textit{Owner Password}\\
\small\verb!   "charles",                                    !\>\textit{User Password}\\
\small\verb!   false,                                        !\>\textit{Linearize}\\
\small\verb!   false,                                        !\>\textit{must be false}\\
\small\verb!   "C:\\output.pdf");                            !\>\textit{Output file}\\
\end{tabbing}
\end{minipage}\\[28mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\begin{tabbing}
\small\verb!Dim permissions As Pdfcrypt.permission () =        !\=\\
\small\verb! {Pdfcrypt.permission.NoEdit,!\\
\small\verb!  Pdfcrypt.permission.NoAssemble};!\\
\small\verb!Cpdflib.ToFileEncrypted!\\
\small\verb!  (pdf,                                          !\>\textit{Document}\\
\small\verb!   Pdfwrite.encryption_method.NewAES128bit(false),  !\>\textit{Encryption}\\
\small\verb!   permissions,                                  !\>\textit{Permissions}\\
\small\verb!   "fred",                                       !\>\textit{Owner Password}\\
\small\verb!   "charles",                                    !\>\textit{User Password}\\
\small\verb!   false,                                        !\>\textit{Linearize}\\
\small\verb!   false,                                        !\>\textit{must be false}\\
\small\verb!   "C:\\output.pdf");                            !\>\textit{Output file}\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{framed}

\section{Ranges}

A \textit{range} is an array of integers representing page numbers, commonly
passed to \texttt{Cpdflib} functions. Sometimes it is treated as an unordered
set, representing pages to be affected by a command, sometimes as an ordered
list representing pages to be merged, for example.

All these functions return a new range, leaving inputs unaltered:

\begin{framed}
\begin{tabular}{ll}
\verb!All(pdf)! & All pages in the document, in order.\\
\verb!Range(n, m)! & Pages from \verb!n! to \verb!m! inclusive, in order.\\
\verb!Even(r)! & Second, fourth etc. pages in a range.\\
\verb!Odd(r)! & First, third etc. pages in a range.\\
\verb!Union(r, s)! & Pages in either range, sans duplicates, unordered.\\
\verb!Difference(r, s)! & Pages in \verb!r! which are not in \verb!s!. Preserves order.\\
\verb!RemoveDuplicates(r)! & Range without duplicates. Preserves order.\\
\verb!Sort(r)! & Sort the range.
\end{tabular}
\end{framed}

\section{Exceptions}

\verb!Cpdflib! functions can raise one exception: \verb!Cpdflib_error! which carries a
string describing the error.

\section{Units of Measure}
The standard unit of measure in \verb!Cpdflib! is the PDF Point, which is 1/72 of an inch. The following conversion functions are available, each taking a \verb!double! and returning a \verb!double!.
\begin{framed}
\begin{tabular}{ll}
\verb!PtOfCm! & Convert centimeters to points\\
\verb!PtOfMm! & Convert millimeters to points\\
\verb!PtOfIn! & Convert inches to points\\[3mm]
\verb!CmOfPt! & Convert points to centimeters\\
\verb!MmOfPt! & Convert points to millimeters\\
\verb!InOfPt! & Convert points to inches
\end{tabular}
\end{framed}

\section{Making Pages Upright}

There are two kinds of rotation in PDF documents - a \textit{viewing rotation}
which can be set, making a PDF viewer such as Acrobat Reader open the docment
with its pages appearing to be rotated by 90, 180 or 270 degrees, and the
\textit{actual rotation} which is how the text and graphics on a page are layed
out (portrait or landscape).

The \verb!Cpdflib! functions \verb!Rotate! and \verb!RotateBy! set or alter
the viewing rotation, and the function \verb!RotateContents! alters the actual
rotation. The function \verb!Upright! changes the viewing rotation to 0 and, if
necessary counterrotates the actual rotation to compensate. This is useful
because many \verb!Cpdflib! functions require upright pages to work as
expected.

\chapter{Merging and Splitting}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!MergeSimple! & Merge two or more PDFs into a single document\\
\verb!Merge! & Merge PDFs, given extra options\\
\verb!MergeSame! & Merge PDFs when the same PDF appears twice or more\\[5mm]
\verb!SelectPages! & Select some pages from a PDF into a new document\\
\verb!SplitOnBookmarks! & Split one document into several, based upon bookmarks
\end{tabular}
\end{framed}
\section{Simple Merging}
The function \verb!MergeSimple! takes an array of PDF objects and returns a PDF object containg the result of merging them. Page numbering is retained.
\begin{framed}
\noindent\textit{Simple Merging of Documents}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc result = Cpdflib.MergeSimple(pdfs)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim result As Pdf.pdfdoc = Cpdflib.MergeSimple(pdfs)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Merging with Options}

There are two boolean options can be set to affect merging. The option \verb!retain_numbering!, if set, keeps the page numbering of the original documents in the merged document. If clear, the pages are renumbered 1, 2, 3 etc. The option \verb!remove_duplicate_fonts!, if set, attempts to remove any duplicate fonts in the result - this works best when merging documents which all came from the same producing program.

\begin{framed}
\noindent\textit{Merging of Documents, with Options}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc result = Cpdflib.Merge(pdfs, false, true)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim result As Pdf.pdfdoc = Cpdflib.Merge(pdf, false, true)!
\end{minipage}\\[5mm]
\end{tabular}

\sloppy\textit{(The first boolean argument is }\verb!retain_numbering!\textit{, the second is }\verb!remove_duplicate_fonts!\textit{.)}
\end{framed}

\section{When a Document Appears Twice}

When using a document twice or more in a merge (for instance, merging \verb!A.pdf! pages 1--3 followed by \verb!B.pdf! followed by \verb!A.pdf! pages 4--6) \verb!Cpdflib! needs to know that both instances of \verb!A.pdf! refer to the same file, so it can share common objects in the output, avoiding content shared between pages (e.g fonts) being included twice.

The function \verb!MergeSame! is equivalent to \verb!Merge!, but an array of strings is also passed: these would typically be the filenames of the documents - but can be any strings which allow \verb!Cpdflib! to distinguish multiple instances of the same file.

\begin{framed}
\noindent\textit{Merging When a Document Appears Twice}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc result = Cpdflib.MergeSame(pdfs, false, true, names)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim result As Pdf.pdfdoc =!\\
\small\verb!  Cpdflib.MergeSame(pdfs, false, true, names)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Selecting Pages}
Any pages can be selected from a PDF with \verb!SelectPages!, giving a range. The pages specified in the range are present in the order in which they are given, including any duplicates (so, for instance, to extract the first three pages of a document, the range would be \verb!1 2 3!, and to duplicate the first page of a four page document, the range would be \verb!1 1 2 3!).
\begin{framed}
\noindent\textit{Selecing Pages from a Document}\\

\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc result = Cpdflib.SelectPages(pdf, pages)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim result As Pdf.pdfdoc = Cpdflib.SelectPages(pdf, pages)!
\end{minipage}
\end{tabular}
\end{framed}

\section{Splitting on Bookmarks}
The \verb!SplitOnBookmarks! function can be used to split a document into chapters, sections etc according to the tree structure of its bookmarks. The \verb!level! argument gives the level of the tree upon which to split. Level 0 indictates just top-level bookmarks, level 1 top-level and next-level-down etc.
\begin{framed}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc [] results = Cpdflib.SplitOnBookmarks(pdf, 0)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim results As Pdf.pdfdoc () = Cpdflib.SplitOnBookmarks(pdf, 0)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Pages}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!ScalePages! & Scale pages and their contents\\
\verb!ScaleToFit! & Scale pages to fit the given dimensions\\
\verb!ScaleToFitPaper! & Scale pages to fit a given paper size\\
%Put this back in
%\verb!ScaleContents! & Scale the contents of a page without scaling the page\\
\verb!ShiftContents! & Shift the contents of a page in x and/or y\\[5mm]
\verb!Rotate! & Change the viewing rotation, in absolute terms\\
\verb!RotateBy! & Change the viewing rotation, in relative terms\\
\verb!RotateContents! & Rotate the page contents by a free angle\\
\verb!Upright! & Reconcile real and viewing rotations\\
\verb!HFlip! & Flip pages horizontally\\
\verb!VFlip! & Flip pages vertically\\[5mm]
\verb!Crop! & Add or change a cropping rectangle\\
\verb!RemoveCrop! & Remove any cropping rectangle\\
\verb!SetMediabox! & Set the media box (page size)
\end{tabular}
\end{framed}

\section{Page Sizes}
 In some of the following functions, standard page sizes can be given. For convenience, here is a list of supported standard page sizes:

  \smallgap
  \begin{tabular}{lll}
  \texttt{a0portrait} & \texttt{a1portrait} & \texttt{a2portrait} \\
  \texttt{a3portrait} & \texttt{a4portrait} & \texttt{a5portrait} \\
  \texttt{a0landscape} & \texttt{a1landscape} & \texttt{a2landscape} \\
  \texttt{a3landscape} & \texttt{a4landscape} & \texttt{a5landscape} \\
  \texttt{usletterportrait} & \texttt{usletterlandscape} & \\
  \texttt{uslegalportrait} & \texttt{uslegallandscape} &
  \end{tabular}

\section{Scale Pages}
The \verb!ScalePages! function scales the page dimensions and its content by the x and y factors given.

\begin{framed}
\noindent\textit{Double the width and height of all the pages in a PDF}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ScalePages(pdf, Cpdflib.All(pdf), 2.0, 2.0)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ScalePages(pdf, Cpdflib.All(pdf), 2.0, 2.0)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

The \verb!ScaleToFitPaper! function scales the page dimensions and its content
to fit the given page dimensions or paper size. If the aspect ratios of the two
page sizes are unequal, the page is scaled to the largest size which will fit
within the new page dimensions, and centered therein.

\begin{framed}
\noindent\textit{Scale pages to fit US Letter paper}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ScaleToFit(pdf, Cpdflib.All(pdf), 500.0, 400.0)!
\small\verb!Cpdflib.ScaleToFitPaper(pdf, Cpdflib.All(pdf), Cpdflib.usletter)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ScaleToFit(pdf, Cpdflib.All(pdf), 500.0, 400.0)!
\small\verb!Cpdflib.ScaleToFitPaper(pdf, Cpdflib.All(pdf), Cpdflib.usletter)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Shift Page Contents}
The \verb!ShiftPages! function moves the content of a given page in x and/or y directions the given number of points. The origin is at the bottom left of the page. Any page rotation is not taken into account.

\begin{framed}
\noindent\textit{Move all pages in a PDF 5pts to the right}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ShiftPageContents(pdf, Cpdflib.All(pdf), 5.0, 0.0)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ShiftPageContents(pdf, Cpdflib.All(pdf), 5.0, 0.0)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Rotate Pages}
\label{upright}
There are two kinds of rotation in PDF documents - a \textit{viewing rotation} which can be set, making a PDF viewer such as Acrobat Reader open the docment with its pages appearing to be rotated by 90, 180 or 270 degrees, and the \textit{actual rotation} which is how the text and graphics on a page are layed out (portrait or landscape).

The \verb!Cpdflib! functions \verb!Rotate! and \verb!RotateBy! set or alter the viewing rotation, and the function \verb!RotateContents! alters the actual rotation. The function \verb!Upright! changes the viewing rotation to 0 and, if necessary counterrotates the actual rotation to compensate. This is useful because many \verb!Cpdflib! functions require upright pages to work as expected.

\begin{framed}
\noindent\textit{Rotate all pages to 90 degrees}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Rotate(pdf, Cpdflib.All(pdf), 90)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Rotate(pdf, Cpdflib.All(pdf), 90)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\begin{framed}
\noindent\textit{Rotate all pages by 90 degrees}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RotateBy(pdf, Cpdflib.All(pdf), 90)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RotateBy(pdf, Cpdflib.All(pdf), 90)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\begin{framed}
\noindent\textit{Rotate the contents of all pages by 30 degrees}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RotateContents(pdf, Cpdflib.All(pdf), 30.0)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RotateContents(pdf, Cpdflib.All(pdf), 30.0)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Flip Pages}
The functions \verb!HFlip! and \verb!VFlip! flip content horizontally and vertically respectively.
\begin{framed}
\noindent\textit{Flip pages horizontally}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.HFlip(pdf, Cpdflib.All(pdf))!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.HFlip(pdf, Cpdflib.All(pdf))!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\begin{framed}
\noindent\textit{Flip pages vertically}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.VFlip(pdf, Cpdflib.All(pdf))!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.VFlip(pdf, Cpdflib.All(pdf))!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Page Size and Page Cropping}
  All PDF files contain a \textit{media box} for each page, giving the
dimensions of the paper. To change these dimensions (without altering the page
contents in any way), use the \verb!SetMediabox! function.

\begin{framed}
\noindent\textit{Set media box (page size)}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetMediabox!\\
\verb!  (pdf, Cpdflib.All(pdf), 0.0, 0.0, 100.0, 200.0)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetMediabox!\\
\verb!  (pdf, Cpdflib.All(pdf), 0.0, 0.0, 100.0, 200.0)!
\end{minipage}\\[5mm]
\end{tabular}

\vspace{2mm}
\noindent\textit{The four floating point arguments are minimum x, minimum y, maximum x, maximum
  y. The origin is at (0, 0) with x coordinates increasing to the right, y coordinates increasing upwards.}

\end{framed}

  PDF file can also optionally contain a \textit{crop box} for each page,
defining to what extent the page is cropped before being displayed or printed.
A crop box can be set, changed and removed, without affecting the underlying
media box. To set or change the crop box use \verb!Crop!. To remove any
existing crop box, use \verb!RemoveCrop!.
\begin{framed}
\noindent\textit{Set crop box}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Crop!\\
\verb!  (pdf, Cpdflib.All(pdf), 0.0, 0.0, 100.0, 200.0)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Crop!\\
\verb!  (pdf, Cpdflib.All(pdf), 0.0, 0.0, 100.0, 200.0)!
\end{minipage}\\[5mm]
\end{tabular}


\vspace{2mm}
\noindent\textit{The four floating point arguments are minimum x, minimum y, maximum x, maximum
  y. The origin is at (0, 0) with x coordinates increasing to the right, y coordinates increasing upwards.}
\end{framed}

\begin{framed}
\noindent\textit{Remove any crop box in place}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveCrop(pdf, Cpdflib.All(pdf))!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveCrop(pdf, Cpdflib.All(pdf))!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Compression}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!Compress! & Compress the data streams within a document\\
\verb!Decompress! & Decompress the data streams within a document
\end{tabular}
\end{framed}
\texttt{Cpdflib} provides basic facilities for compressing and decompressing PDF streams.

\section{Compressing a Document}
To compress the streams in a file, use the \verb!Compress! function. It uses the \verb!/FlateDecode! compression method.

\begin{framed}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Compress(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Compress(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Decompressing a Document}
The \verb!Decompress! function decompresses the streams in a document. If \verb!Cpdflib! finds a compression method it can't deal with, the stream is left compressed.
\begin{framed}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Decompress(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Decompress(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Bookmarks}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!AddBookmarks! & Add or replace bookmarks\\
\verb!MakeBookmark! & Make a bookmark\\
\verb!GetBookmarks! & Get a list of the bookmarks in a document\\
\verb!RemoveBookmarks! & Remove bookmarks from a document
\end{tabular}
\end{framed}

PDF Bookmarks (properly called the \textit{document outline}) represent a tree
of references to parts of the file, typically displayed at the side of the
screen. The user can click on one to move to the specified place.
\verb!Cpdflib! provides facilities to list, add, and remove bookmarks. The
format used by the list and add operations is the same, so you can feed the
output of one into the other, for instance to copy bookmarks.

Each bookmark has four elements:
\begin{framed}
\begin{tabular}{lll}
\verb!level! & Integer & Level of bookmark (0 = top level, 1 = next level etc.)\\
\verb!text! & String & Bookmark text e.g "Section 1B"\\
\verb!target! & Integer & The destination page number\\
\verb!isopen! & Boolean & If true this bookmark's children are visible
\end{tabular}
\end{framed}
For example:
\begin{framed}
\begin{tabular}{llll}
\texttt{level} & \texttt{string} & \texttt{pagenumber} & \texttt{isopen}\\\\
0 & "Part 1" & 1 & true\\
1 & "Part 1A" & 2 & false\\
1 & "Part 1B" & 3 & false\\
0 & "Part 2" & 8 & false\\
1 & "Part 2a" & 9 & false
\end{tabular}
\end{framed}

If the page number is 0, it indicates that clicking on that entry doesn't move to a page.

To add bookmarks, build a suitable bookmark array using \verb!MakeBookmarks! and call \verb!AddBookmarks!.

\begin{framed}
\noindent\textit{Make and add bookmarks to a document}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdfmarks.bookmark [] marks =!\\
\small\verb!  {Cpdflib.MakeBookmark(0, "Part 1", 1, true),!\\
\small\verb!   Cpdflib.MakeBookmark(1, "Part 1A", 2, false),!\\
\small\verb!   Cpdflib.MakeBookmark(1, "Part 1B", 3, false),!\\
\small\verb!   Cpdflib.MakeBookmark(0, "Part 2", 8, false),!\\
\small\verb!   Cpdflib.MakeBookmark(1, "Part 2a", 9, false)};!\\
\small\verb!Cpdflib.AddBookmarks(pdf, marks);!
\end{minipage}\\[18mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim marks As Pdfmarks.bookmark () =!\\
\small\verb!  {Cpdflib.MakeBookmark(0, "Part 1", 1, true),!\\
\small\verb!   Cpdflib.MakeBookmark(1, "Part 1A", 2, false),!\\
\small\verb!   Cpdflib.MakeBookmark(1, "Part 1B", 3, false),!\\
\small\verb!   Cpdflib.MakeBookmark(0, "Part 2", 8, false),!\\
\small\verb!   Cpdflib.MakeBookmark(1, "Part 2a", 9, false)}!\\
\small\verb!Cpdflib.AddBookmarks(pdf, marks)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}
It's important that the bookmarks passed to \verb!AddBookmarks! are consistent - that is, that the levels represent a proper tree form.

The function \verb!GetBookmarks! returns an array of all the bookmarks (if any) in a document.

\begin{framed}
\noindent\textit{Get the bookmarks from a PDF}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdfmarks.bookmark [] marks = Cpdflib.GetBookmarks(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim marks As Pdfmarks.bookmark () = Cpdflib.GetBookmarks(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

The bookmark data structure can then be inspected:
\begin{framed}
\noindent\textit{Write the title of a bookmark 'mark' to screen}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Console.WriteLine(mark.text)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Console.WriteLine(mark.text)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

The bookmarks in a document can be removed with \verb!RemoveBookmarks!.
\begin{framed}
\noindent\textit{Remove bookmarks}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveBookmarks(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveBookmarks(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Presentations}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!AddPresentation! & Make a PDF into a Powerpoint-style presentation\\
\end{tabular}
\end{framed}
The PDF file format, starting at Version 1.1, provides for simple slide-show
presentations in the manner of Microsoft Powerpoint. These can be played in
Acrobat and possibly other PDF viewers, typically started by entering
full-screen mode. The \verb!AddPresentation! operation allows such a
presentation to be built from any PDF file.

There are several transition styles:

\begin{description}
  \item[Split]Two lines sweep across the screen, revealing the new page. By
default the lines are horizontal. If the \verb!vertical! flag is set, vertical lines are used instead.
  \item[Blinds]Multiple lines sweep across the screen, revealing the new page.
By default the lines are horizontal. If the \verb!vertical! flag is set, vertical lines are used instead.
  \item[Box]A rectangular box sweeps inward from the edges of the page. Set the
\verb!outward! argument to make it sweep from the center to the edges.
  \item[Wipe]A single line sweeps across the screen from one edge to the other
in a direction specified by the \verb!direction! argument (see below).
  \item[Dissolve]The old page dissolves gradually to reveal the new one.
  \item[Glitter]The same as \textbf{Dissolve} but the effect sweeps across the
page in the direction specified by the \verb!direction! argument.
\end{description}

It is the transition \textit{from} each page named which is altered. The
\verb!effect_duration! option specifies the length of time in seconds for the
transition itself. The \verb!duration! option specifies the maximum time in
seconds that the page is displayed before the presentation automatically
advances.

For no automatic advancement, specify a negative number.

The \texttt{direction} argument (for \textbf{Wipe} and \textbf{Glitter} styles
only) specifies the direction of the effect. The following values are valid:
\begin{framed}
\begin{itemize}
  \item[\textbf{0}] Left to right
  \item[\textbf{90}] Bottom to top (\textbf{Wipe} only)
  \item[\textbf{180}] Right to left (\textbf{Wipe} only)
  \item[\textbf{270}] Top to bottom
  \item[\textbf{315}] Top-left to bottom-right (\textbf{Glitter} only)
\end{itemize}
\end{framed}

\begin{framed}
\noindent\textit{Make a PDF presentation}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\# / VB} &
\begin{minipage}{4in}
\begin{tabbing}
\small\verb!Cpdflib.AddPresentation           !\=\\
\small\verb!  (pdf, !\>\textit{Document}\\
\small\verb!   Cpdflib.All(pdf),!\>\textit{Range}\\
\small\verb!   Cpdflib.transition.Blinds,!\>\textit{Transition}\\
\small\verb!   1.0,!\>\textit{Duration}\\
\small\verb!   False,!\>\textit{Vertical Flag}\\
\small\verb!   False,!\>\textit{Outward Flag}\\
\small\verb!   0,!\>\textit{Direction}\\
\small\verb!   0.5)!\>\textit{Effect Duration}\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{framed}

\chapter{Logos, Watermarks and Stamps}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!StampOn! & Stamp a page over another one\\
\verb!StampUnder! & Stamp a page under another one\\
\verb!CombinePages! & Combine the contents of pages together\\[5mm]
\verb!AddText! & Add text, dates, stamps, times and bates numbers\\
\verb!RemoveText! & Remove text added with \verb!AddText!
\end{tabular}
\end{framed}

\section{Adding a Logo or Watermark}


The \verb!StampOn! and \verb!StampUnder! functions stamp the first page of a source PDF onto or under each page in the given range of a given document.
\begin{framed}
\noindent\textit{Stamp a source PDF on or under some pages of a document}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.StampOn(sourcepdf, pdf, range)!
\small\verb!Cpdflib.StampUnder(sourcepdf, pdf, range)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.StampOn(sourcepdf, pdf, range)!
\small\verb!Cpdflib.StampUnder(sourcepdf, pdf, range)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

The \verb!CombinePages! function takes two PDF documents and stamps each page of one over the corresponding page in the other. Page attributes (such as the display rotation) are taken from the "under" file. For best results, remove any rotation differences in the two files using \verb!Upright! and \verb!SetMediabox! first.
\begin{framed}
\noindent\textit{Combine pages}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Pdf.pdfdoc result =!\\
\small\verb!  Cpdflib.CombinePages(pdf_over, pdf_under)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim result As Pdf.pdfdoc =!\\
\small\verb!  Cpdflib.CombinePages(pdf_over, pdf_under)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Stamp Text, Dates and Times}
The \verb!AddText! function stamps text, dates, or times over one or more pages of a document. The position, color, font and size may be customised.

Here is the basic usage. We describe each of the options below.
\begin{framed}
\noindent\textit{Stamp Text}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\# / VB} &
\begin{minipage}{4in}
\begin{tabbing}
\small\verb!Cpdflib.AddText                       !\=\\
\small\verb!  (pdf,!\>\textit{Document}\\
\small\verb!   Cpdflib.All(pdf),!\>\textit{Range}\\
\small\verb!   "This is Page %Page",!\>\textit{Text}\\
\small\verb!   Cpdf.position.NewTopLeft(10.0),!\>\textit{Position}\\
\small\verb!   1.0,!\>\textit{Line spacing}\\
\small\verb!   0,!\>\textit{Starting Bates Number}\\
\small\verb!   Pdftext.standard_font.Courier,!\>\textit{Font}\\
\small\verb!   24.0,!\>\textit{Font Size}\\
\small\verb!   Cpdflib.Red,!\>\textit{Text Color}\\
\small\verb!   false,!\>\textit{If set, stamp on shorter side}\\
\small\verb!   false,!\>\textit{If set, stamp underneath}\\
\small\verb!   true)!\>\textit{If set, stamp relative to cropbox}\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{framed}

Several special formatting codes (similar to those found in the \verb!printf! function in most programming languages) are available.
\subsection{Page Numbers}
  \vspace{2mm}
  \begin{tabular}{ll}
    \texttt{\%Page} & Page number in arabic notation (1, 2, 3\ldots) \\
    \texttt{\%roman} & Page number in lower-case roman notation (i, ii, iii\ldots) \\
    \texttt{\%Roman} & Page number in upper-case roman notation (I, II, III\ldots) \\
    \texttt{\%EndPage} & Last page of document in arabic notation \\
  \end{tabular}

  \vspace{2mm}
  \noindent For example, the format \texttt{"Page~\%Page~of~\%EndPage"} might become "Page~5~of~17".

\subsection{Date and Time Formats}
  \begin{ctabular}{ll}
    \texttt{\%a} & Abbreviated weekday name (Sun, Mon etc.)\\
    \texttt{\%A} & Full weekday name (Sunday, Monday etc.)\\
    \texttt{\%b} & Abbreviated month name (Jan, Feb etc.)\\
    \texttt{\%B} & Full month name (January, February etc.)\\
    \texttt{\%d} & Day of the month (01--31) \\
    \texttt{\%e} & Day of the month (1--31) \\
    \texttt{\%H} & Hour in 24-hour clock (00--23)\\
    \texttt{\%I} & Hour in 12-hour clock (01--12)\\
    \texttt{\%j} & Day of the year (001--366)\\
    \texttt{\%m} & Month of the year (01--12)\\
    \texttt{\%M} & Minute of the hour (00--59)\\
    \texttt{\%p} & "a.m" or "p.m"\\
    \texttt{\%S} & Second of the minute (00--61)\\
    \texttt{\%T} & Same as \%H:\%M:\%S\\
    \texttt{\%u} & Weekday (1--7, 1 = Monday)\\
    \texttt{\%w} & Weekday (0--6, 0 = Monday)\\
    \texttt{\%Y} & Year (0000--9999)\\
    \texttt{\%\%} & The \% character.
  \end{ctabular}
\subsection{Bates Numbers}
  Unique page identifiers can be specified by putting \verb!%Bates! in the string.
The starting point can be set with the \texttt{bates} argument. For example:
  \begin{framed}
    \small\verb!"Page ID: %Bates"!
  \end{framed}
  \noindent when \verb!bates! is 45 would number each page 45, 46, 47\ldots
\subsection{Position}
  The position of the text may be specified in absolute terms:
  \begin{framed}
    \small\verb!NewPosCentre(200.0, 200.0)!
  
    \vspace{2.5mm}
    \noindent Position the center of the baseline text at (200pt, 200pt)

    \vspace{2.5mm}
    \small\verb!NewPosLeft(200.0, 200.0)!
  
    \vspace{2.5mm}
    \noindent Position the left of the baseline of the text at (200pt, 200pt)

    \vspace{2.5mm}
    \small\verb!NewPosRight(200.0, 200.0)!
  
    \vspace{2.5mm}
    \noindent Position the right of the baseline of the text at (200pt, 200pt)

  \end{framed}

  \noindent Position relative to certain common points can also be set:

  \begin{framed}
    \noindent\begin{tabular}{ll}
      \small\verb!NewTop(10)! & Center of baseline 10 pts down from the top center \\
      \small\verb!NewTopLeft(10)! & Left of baseline 10 pts down and in from top left \\
      \small\verb!NewTopRight(10)! & Right of baseline 10 pts down and left from top right\\
      \small\verb!NewLeft(10)! & Left of baseline 10 pts in from center left \\
      \small\verb!NewBottomLeft(10)! & Left of baseline 10 pts in and up from bottom left \\
      \small\verb!NewBottom(10)! & Center of baseline 10 pts up from bottom center\\
      \small\verb!NewBottomRight(10)! & Right of baseline 10 pts up and in from bottom right \\
      \small\verb!NewRight(10)! & Right of baseline 10 pts in from the center right \\
    \end{tabular}
  \end{framed}

No attempt is made to take account of the page rotation, so you might like to
use \texttt{-upright} (see \Sref{upright}) first.
   
\subsection{Font and Size}
  The font may be set with the \texttt{font} argument. The 14 Standard PDF fonts are available:

  \vspace{2mm}
  \begin{ctabular}{l}
  TimesRoman\\
  TimesBold\\
  TimesItalic\\
  TimesBoldItalic\\
  Helvetica\\
  HelveticaBold\\
  HelveticaOblique\\
  HelveticaBoldOblique\\
  Courier\\
  CourierBold\\
  CourierOblique\\
  CourierBoldOblique\\
  Symbol\\
  ZapfDingbats
  \end{ctabular}

\noindent The font size can be set with the \texttt{fontsize} option, which
specifies the size in points.
\subsection{Colors}
The \texttt{color} argument allows the color of the text to be set. The following values are predefined (components range between 0 and 1):

  \vspace{2mm}
  \begin{tabular}{ll}
    \textbf{Color} & \textbf{R, G, B} \\ \hline
     white & 1, 1, 1\\
     black & 0, 0, 0\\
     red & 1, 0, 0\\
     green & 0, 1, 0\\
     blue & 0, 0, 1\\
  \end{tabular}

\vspace{2mm}
\noindent The function \verb!Rgb(r, g, b)! can be used to build a color from red, green and blue components.
\subsection{Multi-line Text}
The code \texttt{$\backslash$n} can be included in the text string to move to
the next line. In this case, the vertical position refers to the baseline of
the first line of text (if the position is at the top, top left or top right of
the page) or the baseline of the last line of text (if the position is at the
bottom, bottom left or bottom right).

The \texttt{linespacing} option can be used to increase or decrease the line
spacing, where a spacing of 1 is the standard.

\subsection{Removing Text}
Text added with \texttt{AddText} can be removed using \texttt{RemoveText}:

\begin{framed}
\noindent\textit{Remove text added with AddText}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveText(pdf, range)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveText(pdf, range)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Multipage Facilities}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!TwoUp! & Impose a document two-up\\
\verb!TwoUpStack! & Impose a document two-up, with no scaling\\
\verb!PadBefore! & Add blank pages before some pages\\
\verb!PadAfter! & Add blank pages after some pages
\end{tabular}
\end{framed}
\section{Two-up}
The \verb!TwoUp! function puts two logical pages on each physical page,
rotating them 90 degrees and scaling them down to do so. The \verb!TwoUpStack! variant does the same, but with no scaling, the output page size being twice the input page size.
\begin{framed}
\noindent\textit{Impose pages two-up}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.TwoUp(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.TwoUp(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Inserting Blank Pages}

Sometimes, for instance to get a printing arrangement right, it's useful to be
able to insert blank pages into a PDF file. \verb!Cpdflib! can add blank pages
before (\verb!PadBefore!) a given page or pages, or after (\verb!PadAfter!).
The pages in question are specified by a range.

Here's an example with \verb!PadAfter!:
\begin{framed}
\noindent\textit{Insert blank pages after existing pages one, two and three}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!int[] r = {1, 2, 3}!\\
\verb!Cpdflib.PadAfter(pdf, r)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim r As Integer() r = {1, 2, 3}!\\
\verb!Cpdflib.PadAfter(pdf, r)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Annotations}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!ListAnnotations! & Get the textual content of existing annotations\\
\verb!CopyAnnotations! & Copy annotations from one document to another\\
\verb!RemoveAnnotations! & Remove the annotations from a document
\end{tabular}
\end{framed}
An annotation consists of a page number and a string. The two components can be accessed using the dot notation. For instance, if the annotation variable is \verb!annot!:

\begin{framed}
  \begin{tabular}{ll}
    To access page number & \verb!annot.annotation_page!\\
    To access annotation contents & \verb!annot.annotation_content!
  \end{tabular}
\end{framed}

To list the annotations in a document, use \verb!ListAnnotations!:
\begin{framed}
\noindent\textit{List annotations in a document}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.annotation [] annots = Cpdflib.ListAnnotations(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim annots As Cpdflib.annotation () =!
\small\verb!  Cpdflib.ListAnnotations(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

To copy annotations from one document to another, use \verb!CopyAnnotations!:
\begin{framed}
\noindent\textit{Copy annotations from one document to another}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.CopyAnnotations(source_pdf, target_pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.CopyAnnotations(source_pdf, target_pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

To remove annotations from a documents, use \verb!RemoveAnnotations!:
\begin{framed}
\noindent\textit{Remove annotations from a document}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveAnnotations(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveAnnotations(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Document Information}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!ListFonts! & List the fonts in a document\\[5mm]
\verb!GetVersion! & Get the PDF version number\\
\verb!GetTitle! & Get the title of a document\\
\verb!GetAuthor! & Get the author of a document\\
\verb!GetSubject! & Get the subject of a document\\
\verb!GetKeywords! & Get the keyword list from a document\\
\verb!GetCreator! & Get the creator name from a document\\
\verb!GetProducer! & Get the producer name from a document\\
\verb!GetCreationDate! & Get the creation date of a document\\
\verb!GetModificationDate! & Get the modification date of a document\\[5mm]
\verb!SetVersion! & Set the PDF version number\\
\verb!SetTitle! & Set the title of a document\\
\verb!SetAuthor! & Set the author of a document\\
\verb!SetSubject! & Set the subject of a document\\
\verb!SetKeywords! & Set the keyword list in a document\\
\verb!SetCreator! & Set the creator name in a document\\
\verb!SetProducer! & Set the producer name in a document\\
\verb!SetCreationDate! & Set the creation date in a document\\
\verb!SetModifcationDate! & Set the modification date in a document\\[5mm]
\verb!MarkTrapped! & Mark a PDF as trapped\\
\verb!MarkUntrapped! & Mark a PDF as untrapped\\
\verb!GetPageInfo! & Get information for each page\\
\verb!SetPageLayout! & Set the page layout\\
\verb!SetPageMode! & Set the page mode\\
\verb!HideToolbar! & Hide or reveal the viewer's toolbar\\
\verb!HideMenubar! & Hide or reveal the viewer's menubar\\
\verb!FitWindow! & Set or unset Fit-to-Window\\
\verb!CenterWindow! & Set or unset Center-Window\\
\verb!DisplayDocTitle! & Set or unset display of document title\\[5mm]
\end{tabular}
\end{framed}

\section{Listing Fonts}

The \verb!ListFonts! returns an array of \verb!font_info! structures, each member of which can be accessed with the dot notation:

\begin{framed}
\begin{tabular}{ll}
\verb!font_pagenumber! & \verb!integer!\\
\verb!font_name! & \verb!string!\\
\verb!font_subtype! & \verb!string!\\
\verb!font_basename! & \verb!string!\\
\verb!font_encoding! & \verb!string!\\
\end{tabular}
\end{framed}

For example:

\begin{framed}
\noindent\textit{List fonts}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.font_info [] fonts = Cpdflib.ListFonts(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim fonts As Cpdflib.font_info () = Cpdflib.ListFonts(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

might return the array:

\begin{framed}
\small\begin{tabular}{lllll}
\textbf{Page} & \textbf{Name} & \textbf{Type} & \textbf{Base Name} & \textbf{Encoding}\\
1 & /F245 & /Type0 & /Cleargothic-Bold & /Identity-H\\
1 & /F247 & /Type0 & /ClearGothicSerialLight & /Identity-H\\
1 & /F248 & /Type1 & /Times-Roman & /WinAnsiEncoding\\
1 & /F250 & /Type0 & /Cleargothic-RegularItalic & /Identity-H\\
2 & /F13 & /Type0 & /Cleargothic-Bold & /Identity-H\\
2 & /F16 & /Type0 & /Arial-ItalicMT & /Identity-H\\
2 & /F21 & /Type0 & /ArialMT & /Identity-H\\
2 & /F58 & /Type1 & /Times-Roman & /WinAnsiEncoding\\
2 & /F59 & /Type0 & /ClearGothicSerialLight & /Identity-H\\
2 & /F61 & /Type0 & /Cleargothic-BoldItalic & /Identity-H\\
2 & /F68 & /Type0 & /Cleargothic-RegularItalic & /Identity-H\\
3 & /F47 & /Type0 & /Cleargothic-Bold & /Identity-H\\
3 & /F49 & /Type0 & /ClearGothicSerialLight & /Identity-H\\
3 & /F50 & /Type1 & /Times-Roman & /WinAnsiEncoding\\
3 & /F52 & /Type0 & /Cleargothic-BoldItalic & /Identity-H\\
3 & /F54 & /Type0 & /TimesNewRomanPS-BoldItalicMT & /Identity-H\\
3 & /F57 & /Type0 & /Cleargothic-RegularItalic & /Identity-H\\
4 & /F449 & /Type0 & /Cleargothic-Bold & /Identity-H\\
4 & /F451 & /Type0 & /ClearGothicSerialLight & /Identity-H\\
4 & /F452 & /Type1 & /Times-Roman & /WinAnsiEncoding
\end{tabular}
\end{framed}

The first column gives the page number, the second the internal unique font
name, the third the type of font (Type1, TrueType etc), the fourth the PDF font
name, the fifth the PDF font encoding.

\section{Getting Document Information}
There are a number of functions for getting document information. Each function takes the document as an argument and returns an \verb!integer! or \verb!string!.

\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{lll}
\textbf{Function} & \textbf{Returns} & \textbf{Description}\\
\verb!GetVersion! & \verb!integer! & Get the PDF version number\\
\verb!GetTitle! & \verb!string! & Get the title of a document\\
\verb!GetAuthor! & \verb!string! & Get the author of a document\\
\verb!GetSubject! & \verb!string! & Get the subject of a document\\
\verb!GetKeywords! & \verb!string! & Get the keyword list from a document\\
\verb!GetCreator! & \verb!string! & Get the creator name from a document\\
\verb!GetProducer! & \verb!string! & Get the producer name from a document\\
\verb!GetCreationDate! & \verb!date! & Get the creation date of a document\\
\verb!GetModificationDate! & \verb!date!& Get the modification date of a document
\end{tabular}
\end{framed}
\noindent(Dates are a special kind of string - see Appendix A). For example, to return the author of a document:
\begin{framed}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!string author = Cpdflib.GetAuthor(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim author As String = Cpdflib.GetAuthor(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Setting Document Information}
There are a number of functions for setting document information. Each function takes the document as an argument, followed by a single other argument.

\begin{framed}
\noindent\begin{tabular}{lll}
\textbf{Function} & \textbf{Argument} & \textbf{Description}\\
\verb!SetVersion! & \verb!integer! & Set the PDF version number\\
\verb!SetTitle! & \verb!string! & Set the title of a document\\
\verb!SetAuthor! & \verb!string! & Set the author of a document\\
\verb!SetSubject! & \verb!string! & Set the subject of a document\\
\verb!SetKeywords! & \verb!string! & Set the keyword list in a document\\
\verb!SetCreator! & \verb!string! & Set the creator name in a document\\
\verb!SetProducer! & \verb!string! & Set the producer name in a document\\
\verb!SetCreationDate! & \verb!date! & Set the creation date in a document\\
\verb!SetModifcationDate! & \verb!date! & Set the modification date in a document
\end{tabular}
\end{framed}
\noindent(Dates are a special kind of string - see Appendix A). For example, to set the title of a document, and set its version number to PDF 1.2:
\begin{framed}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetVersion(pdf, 2)!\\
\verb!Cpdflib.SetTitle(pdf, "Forces of Nature")!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetVersion(pdf, 2)!\\
\verb!Cpdflib.SetTitle(pdf, "Forces of Nature")!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}


\section{Mark Trapped / Untrapped}
These two functions can be used to mark a PDF trapped or untrapped. They take one argument---the document.

\section{Get and Set Page Layout and Mode}
The \verb!SetPageLayout! function specifies the page layout to be used
when a document is opened in, for instance, Acrobat. The possible
values are provided in the \verb!layout! object in the \verb!Cpdflib! module:

\begin{framed}
  \begin{tabular}{ll}
    \texttt{SinglePage} & \vspace{2mm} \parbox{8cm}{Display one page at a time} \\
    \texttt{OneColumn} & \vspace{2mm} \parbox{8cm}{Display the pages in one column} \\
    \texttt{TwoColumnLeft} & \vspace{2mm} \parbox{8cm}{Display the pages in two columns, odd numbered pages on the left} \\
    \texttt{TwoColumnRight} & \vspace{2mm} \parbox{8cm}{Display the pages in two columns, even numbered pages on the left} \\
    \texttt{TwoPageLeft} & \vspace{2mm} \parbox{8cm}{(PDF 1.5 and above) Display the pages two at a time, odd numbered pages on the left} \\
    \texttt{TwoPageRight} & \vspace{2mm} \parbox{8cm}{(PDF 1.5 and above) Display the pages two at a time, even numbered pages on the left}
  \end{tabular}
\end{framed}

For instance:

\begin{framed}
\noindent\textit{Set document to open with pages in Two Columns, even numbered pages on the left.}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetPageLayout(pdf, Cpdflib.layout.TwoColumnRight)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetPageLayout(pdf, Cpdflib.layout.TwoColumnRight)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

  The \textit{page mode} in a PDF file defines how a viewer should display the
document when first opened and can be set with the \verb!SetPageMode! function. Possible values, in the \verb!pagemode! object in \verb!Cpdflib! are:
\begin{framed}
  \begin{tabular}{ll}
    \texttt{UseNone} & \vspace{2mm} \parbox{8cm}{Neither document outline nor thumbnail images visible} \\
    \texttt{UseOutlines} & \vspace{2mm} \parbox{8cm}{Document outline (bookmarks) visible} \\
    \texttt{UseThumbs} & \vspace{2mm} \parbox{8cm}{Thumbnail images visible} \\
    \texttt{FullScreen} & \vspace{2mm} \parbox{8cm}{Full-screen mode (no menu bar, window controls, or anything but the document visible)} \\
    \texttt{UseOC} & \vspace{2mm} \parbox{8cm}{(PDF 1.5 and above) Optional content group panel visible} \\
    \texttt{UseAttachments} & \vspace{2mm} \parbox{8cm}{(PDF 1.5 and above) Attachments panel visible}
  \end{tabular}
\end{framed}
For instance:

\begin{framed}
\noindent\textit{Set document to open with bookmarks visible}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetPageMode(pdf, Cpdflib.pagemode.UseOutlines)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetPageMode(pdf, Cpdflib.pagemode.UseOutlines)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

Page information (media box, crop box) can be returned with the function \verb!GetPageInfo!, which takes a document,and returns an array of \verb!page_info! objects, one for each page in the document.

Each object has two members \verb!mediabox! and \verb!cropbox!, each of which is a \verb!box! object. A box object contains four floating point objects (\verb!minx!, \verb!maxx!, \verb!miny!, \verb!maxy!) describing the box in question. For example:

\begin{framed}
\noindent\textit{Read and print the minimum x coordinate of the media box of the first page}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.page_info [] pageinfo = Cpdflib.GetPageInfo(pdf)!
\small\verb!Console.WriteLine(pageinfo[0].mediabox.minx)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim pageinfo As Cpdflib.page_info() = Cpdflib.GetPageInfo(pdf)!
\small\verb!Console.WriteLine(pageinfo(0).mediabox.minx)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}


\section{Other View Settings}
The following functions take a document, and a boolean, to indicate if the option is to be set or unset.
\begin{framed}
  \begin{tabular}{ll}
    \verb!HideToolbar! & \vspace{2mm} \parbox{8cm}{Hide the viewer's toolbar} \\
    \verb!HideMenubar! & \vspace{2mm} \parbox{8cm}{Document outline (bookmarks) visible} \\
    \verb!HideWindowUi! & \vspace{2mm} \parbox{8cm}{Hide the viewer's scroll bars} \\
    \verb!FitWindow! & \vspace{2mm} \parbox{8cm}{Resize the document's windows to fit size of first page} \\
    \verb!CenterWindow! & \vspace{2mm} \parbox{8cm}{Position the document window in the center of the screen} \\
    \verb!DisplayDocTitle! & \vspace{2mm} \parbox{8cm}{Display the document title instead of the file name in the title bar}
  \end{tabular}
\end{framed}
For instance:
\begin{framed}
\noindent\textit{Set document to open resized to fit first page}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.FitWindow(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.FitWindow(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Document Metadata}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!SetMetadataFromFile! & Set the Document Metadata from a file\\
\verb!SetMetadataFromByteArray! & Set the Document Metadata from a byte array\\
\verb!GetMetadata! & Get the document metadata as a byte array\\
\verb!RemoveMetadata! & Remove the metadata from a document\\
\end{tabular}
\end{framed}
  PDF files can contain a piece of arbitrary metadata, often in XML format.
This is typically stored in an uncompressed stream, so that other applications
can read it without having to decode the whole PDF. To set the metadata from a file:
\begin{framed}
\noindent\textit{Add metadata from a file}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetMetadataFromFile(pdf, "C:\\data.xml")!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetMetadataFromFile(pdf, "C:\\data.xml")!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

To set from a byte array:

\begin{framed}
\noindent\textit{Set Metadata from Byte Array}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetMetadataFromByteArray(pdf, bytes)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.SetMetadataFromByteArray(pdf, bytes)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

Return the metadata as a byte array:

\begin{framed}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!byte [] bytes = Cpdflib.GetMetadata(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Dim bytes As Byte () = Cpdflib.GetMetadata(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}


To remove any metadata from a file:

\begin{framed}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveMetadata(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveMetadata(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{File Attachments}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!AttachFile! & Attach a file to the document\\
\verb!RemoveAttachedFiles! & Remove all attached files from a document
\end{tabular}
\end{framed}

PDF supports adding attachments (files of any kind, including other PDFs) to an
existing file. The \verb!Cpdflib! library supports adding and removing
\textit{top-level attachments} --- that is, ones which are associated with the
document as a whole rather than with an individual page.

To add an attachment, use \verb!AttachFile!. Multiple files can be attached by
multiple invocations of \verb!AttachFile!, and will appear in Acrobat's list
in the order added.
\begin{framed}
\noindent\textit{Attach the file} \verb!sheet.xls! \textit{to a document}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.AttachFile(pdf, "C:\\sheet.xls")!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.AttachFile(pdf, "C:\\sheet.xls")!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

To remove all attached files, use \verb!RemoveAttachedFiles!:

\begin{framed}
\noindent\textit{Remove attached files}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveAttachedFiles(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.RemoveAttachedFiles(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\chapter{Miscellaneous}
\begin{framed}
\noindent\textit{Function Summary}\\[2mm]
\noindent\begin{tabular}{ll}
\verb!BlackText! & Blacken text\\
\verb!BlackLines! & Blacken lines\\
\verb!BlackFills! & Blacken fills\\
\verb!ThinLines! & Make all lines at least a certain width\\
\verb!Draft! & Remove images for draft printing\\[5mm]
\verb!CopyId! & Copy the unique document ID from one document to another\\
\end{tabular}
\end{framed}

\section{Graphical Alterations}

Sometimes PDF output from an application (for instance, a web browser) has text
in colors which would not print well on a grayscale printer. The
\verb!BlackText! operation blackens all text on the given pages so it will be
readable when printed. This will not work on text which has been converted to
outlines, nor on text which is part of a form.

The \verb!BlackLines! function does the same for lines and \verb!BlackFills!
for fill colors.

\begin{framed}
\noindent\textit{Blacken lines in a document}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.BlackLines(pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.BlackLines(pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

Quite often, applications will use very thin lines, or even the value of 0,
which in PDF means "The thinnest possible line on the output device". This
might be fine for on-screen work, but when printed on a high resolution device,
such as by a commercial printer, they may be too faint, or disappear
altogether. The \verb!ThinLines! function prevents this by changing all lines
thinner than the given minimal thickness to the given width. For example:

\begin{framed}
\noindent\textit{Thicken lines to at least 2pt}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ThinLines(pdf, Cpdflib.All(pdf), 2.0)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.ThinLines(pdf, Cpdflib.All(pdf), 2.0)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Draft Documents}
    The \verb!Draft! function removes bitmap (photographic) images from a
file, so that it can be printed with less ink. Optionally, the the
boxes argument can be set, filling the spaces left blank with a
crossed box denoting where the image was. This is not guaranteed to be fully
visible in all cases (the bitmap may be have been partially covered by vector
objects or clipped in the original). For example:
\begin{framed}
\noindent\textit{Remove images, replacing with crossed boxes}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Draft(pdf, Cpdflib.All(pdf), true)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.Draft(pdf, Cpdflib.All(pdf), true!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\section{Document Identification}
  The \verb!CopyId! option copies the ID from the given file to the
input, writing to the output.
  If there is no ID in the source file, the operation fails.

\begin{framed}
\noindent\textit{Remove attached files}

\vspace{2mm}
\noindent\begin{tabular}{rl}
\small\sffamily\textbf{C\#} &
\begin{minipage}{4in}
\small\verb!Cpdflib.CopyId(from_pdf, to_pdf)!
\end{minipage}\\[5mm]
\small\sffamily\textbf{VB} &
\begin{minipage}{4in}
\small\verb!Cpdflib.CopyId(from_pdf, to_pdf)!
\end{minipage}\\[5mm]
\end{tabular}
\end{framed}

\appendix
\chapter{Dates}
\label{dates}
\index{dates!defined}
Dates in PDF are specified according to the following format:

\begin{framed}
\texttt{D:YYYYMMDDHHmmSSOHH'mm'}\\\\where:

\begin{itemize}
  \item \texttt{YYYY} is the year;
  \item \texttt{MM} is the month;
  \item \texttt{DD} is the day (01-31);
  \item \texttt{HH} is the hour (00-23);
  \item \texttt{mm} is the minute (00-59);
  \item \texttt{SS} is the second (00-59);
  \item \texttt{O} is the relationship of local time to Universal Time (UT), denoted by '+', '-' or 'Z';
  \item \texttt{HH} is the absolute value of the offset from UT in hours (00-23);
  \item \texttt{mm} is the absolute value of the offset from UT in minutes (00-59).
\end{itemize}
\end{framed}

\noindent A contiguous prefix of the parts above can be used instead, for lower
accuracy dates. For example:

\begin{framed}
   \small\noindent\verb!D:2011! (2011)
   
   \vspace{1.5mm}
   \noindent\verb!D:20110103! (3rd March 2011)

   \vspace{1.5mm}
   \noindent\verb!D:201101031854-08'00'! (3rd March 2011, 6:54PM, US Pacific Standard Time)
   
\end{framed}
\chapter{Example Program in C\#}
This program loads a file from disk, adds page numbers, and then writes the file encrypted to disk.
\begin{small}
\begin{verbatim}
namespace ConsoleApplication1 {
    class Program {
        static void Main(string[] args) {
          //Load the (unencrypted) input file
          Pdf.pdfdoc pdf = Cpdflib.FromFile("C:\\input.pdf");

          //Resolve any rotation of pages
          Cpdflib.Upright(pdf, Cpdflib.All(pdf));

          //Add page numbers
          Cpdflib.AddText
            (pdf,                                 //Document
             Cpdflib.All(pdf),                    //Range
             "Page %Page of %EndPage",            //Text
             Cpdf.position.NewTop(20.0),          //Position
             1.0,                                 //Line spacing
             0,                                   //Bates number
             Pdftext.standard_font.TimesBold,     //Font
             12.0,                                //Font Size
             Cpdflib.Black,                       //Text Color
             false,                               //If set, stamp on shorter side
             false,                               //If set, stamp underneath
             true);                               //If set, stamp relative to cropbox

          //Write to file, encrypted with AES encryption
          Pdfcrypt.permission[] permissions =
            {Pdfcrypt.permission.NoEdit, Pdfcrypt.permission.NoAssemble};
          Cpdflib.ToFileEncrypted
             (pdf,                                             //Document
              Pdfwrite.encryption_method.NewAES128bit(false),  //Encryption method
              permissions,                                     //Permissions
              "fred",                                          //Owner Password
              "charles",                                       //User Password
              false,                                           //Linearize
              false,                                           //Must be false
              "C:\\output.pdf");                               //Output filename
        }
    }
}
\end{verbatim}
\end{small}
\chapter{Example Program in VB.NET}
This program loads a file from disk, adds page numbers, and then writes the file encrypted to disk.
\begin{small}
\begin{verbatim}
Module Module1

    Sub Main()
        'Load the (unencrypted) input file
        Dim pdf As Pdf.pdfdoc = Cpdflib.FromFile("C:\\input.pdf")

        'Resolve any rotation of pages
        Cpdflib.Upright(pdf, Cpdflib.All(pdf))

        'Add page numbers
        Cpdflib.AddText _
          (pdf, Cpdflib.All(pdf), "Page %Page of %EndPage", _
          Cpdf.position.NewTop(20.0), 1.0, 0, _
          Pdftext.standard_font.TimesBold, _
          12.0, Cpdflib.Black, False, False, True)

        'Write to file, encrypted with AES encryption
        Dim permissions As Pdfcrypt.permission() = _
          {Pdfcrypt.permission.NoEdit, Pdfcrypt.permission.NoAssemble}
        Cpdflib.ToFileEncrypted _
          (pdf, _
           Pdfwrite.encryption_method.NewAES128bit(False), _
           permissions, "fred", "charles", _
           False, False, "C:\\output.pdf")
    End Sub

End Module
\end{verbatim}
\end{small}

\backmatter
\printindex
\end{document}

